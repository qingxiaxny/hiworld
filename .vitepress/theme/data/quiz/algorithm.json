[
  { "q": "快速排序的平均时间复杂度是？", "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"], "answer": "O(n log n)", "explanation": "快速排序平均时间复杂度 O(n log n)，最坏 O(n²)。" },
  { "q": "二分查找的前提条件是？", "options": ["数组有序", "数组无序", "链表结构", "树结构"], "answer": "数组有序", "explanation": "二分查找要求数组有序。" },
  { "q": "栈的特点是？", "options": ["先进先出", "后进先出", "随机访问", "双向访问"], "answer": "后进先出", "explanation": "栈是 LIFO（Last In First Out）数据结构。" },
  { "q": "哈希表查找的平均时间复杂度是？", "options": ["O(n)", "O(1)", "O(log n)", "O(n²)"], "answer": "O(1)", "explanation": "哈希表平均查找时间复杂度 O(1)。" },
  { "q": "递归必须有什么条件？", "options": ["循环", "终止条件", "全局变量", "多线程"], "answer": "终止条件", "explanation": "递归必须有终止条件，否则会无限递归。" },
  { "q": "队列的特点是？", "options": ["后进先出", "先进先出", "随机访问", "双向访问"], "answer": "先进先出", "explanation": "队列是 FIFO（First In First Out）数据结构。" },
  { "q": "二叉搜索树的特点是？", "options": ["无序", "左子树小于根，右子树大于根", "完全平衡", "只有两层"], "answer": "左子树小于根，右子树大于根", "explanation": "二叉搜索树满足左 < 根 < 右的性质。" },
  { "q": "冒泡排序的时间复杂度是？", "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"], "answer": "O(n²)", "explanation": "冒泡排序时间复杂度 O(n²)。" },
  { "q": "链表和数组的主要区别是？", "options": ["没有区别", "链表动态大小，数组固定大小", "数组动态大小", "链表更快"], "answer": "链表动态大小，数组固定大小", "explanation": "链表可动态增长，数组大小固定。" },
  { "q": "深度优先搜索（DFS）使用什么数据结构？", "options": ["队列", "栈", "堆", "哈希表"], "answer": "栈", "explanation": "DFS 使用栈实现，也可用递归。" },
  { "q": "广度优先搜索（BFS）使用什么数据结构？", "options": ["栈", "队列", "堆", "哈希表"], "answer": "队列", "explanation": "BFS 使用队列实现。" },
  { "q": "归并排序的空间复杂度是？", "options": ["O(1)", "O(n)", "O(log n)", "O(n²)"], "answer": "O(n)", "explanation": "归并排序需要额外空间存储临时数组，空间复杂度 O(n)。" },
  { "q": "什么是动态规划？", "options": ["递归", "将问题分解为子问题并存储结果", "贪心算法", "分治算法"], "answer": "将问题分解为子问题并存储结果", "explanation": "动态规划通过存储子问题结果避免重复计算。" },
  { "q": "堆的特点是？", "options": ["无序", "完全二叉树，满足堆性质", "平衡二叉树", "红黑树"], "answer": "完全二叉树，满足堆性质", "explanation": "堆是完全二叉树，满足堆性质。" },
  { "q": "最小堆的根节点是？", "options": ["最大值", "最小值", "中间值", "随机值"], "answer": "最小值", "explanation": "最小堆的根节点是最小值。" },
  { "q": "图的两种表示方法是？", "options": ["数组和链表", "邻接矩阵和邻接表", "栈和队列", "树和图"], "answer": "邻接矩阵和邻接表", "explanation": "图可用邻接矩阵或邻接表表示。" },
  { "q": "什么是贪心算法？", "options": ["全局最优", "每步选择局部最优", "动态规划", "回溯算法"], "answer": "每步选择局部最优", "explanation": "贪心算法每步选择局部最优，不一定得到全局最优。" },
  { "q": "二分查找的时间复杂度是？", "options": ["O(n)", "O(log n)", "O(n²)", "O(1)"], "answer": "O(log n)", "explanation": "二分查找时间复杂度 O(log n)。" },
  { "q": "什么是时间复杂度？", "options": ["运行时间", "算法执行时间随输入规模的增长率", "内存使用", "代码行数"], "answer": "算法执行时间随输入规模的增长率", "explanation": "时间复杂度描述算法性能随输入规模的变化。" },
  { "q": "什么是空间复杂度？", "options": ["磁盘空间", "算法使用内存随输入规模的增长率", "代码大小", "变量数量"], "answer": "算法使用内存随输入规模的增长率", "explanation": "空间复杂度描述算法内存使用随输入规模的变化。" }
]
