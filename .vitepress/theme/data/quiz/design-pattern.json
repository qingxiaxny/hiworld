[
  { "q": "单例模式的特点是？", "options": ["多个实例", "全局唯一实例", "工厂创建", "观察者"], "answer": "全局唯一实例", "explanation": "单例模式保证类只有一个实例。" },
  { "q": "工厂模式的作用是？", "options": ["创建单例", "封装对象创建过程", "观察变化", "代理访问"], "answer": "封装对象创建过程", "explanation": "工厂模式封装对象创建，隐藏创建细节。" },
  { "q": "观察者模式用于什么场景？", "options": ["创建对象", "一对多的依赖关系", "代理访问", "适配接口"], "answer": "一对多的依赖关系", "explanation": "观察者模式处理一对多的依赖关系。" },
  { "q": "策略模式的核心思想是？", "options": ["单一职责", "封装算法族，可互换", "开闭原则", "依赖倒置"], "answer": "封装算法族，可互换", "explanation": "策略模式封装一族算法，使其可互换。" },
  { "q": "装饰器模式和继承的区别是？", "options": ["没有区别", "装饰器更灵活，运行时扩展", "继承更灵活", "装饰器更快"], "answer": "装饰器更灵活，运行时扩展", "explanation": "装饰器模式比继承更灵活，支持运行时扩展。" },
  { "q": "适配器模式的作用是？", "options": ["创建对象", "转换接口，使不兼容的类协同工作", "观察变化", "代理访问"], "answer": "转换接口，使不兼容的类协同工作", "explanation": "适配器模式转换接口，使不兼容的类协同工作。" },
  { "q": "代理模式的作用是？", "options": ["创建对象", "控制对象访问", "观察变化", "适配接口"], "answer": "控制对象访问", "explanation": "代理模式控制对象访问，可添加额外功能。" },
  { "q": "模板方法模式的特点是？", "options": ["定义算法骨架，子类实现细节", "创建对象", "观察变化", "代理访问"], "answer": "定义算法骨架，子类实现细节", "explanation": "模板方法模式定义算法骨架，子类实现具体步骤。" },
  { "q": "建造者模式适合什么场景？", "options": ["简单对象", "复杂对象的分步构建", "单例对象", "代理对象"], "answer": "复杂对象的分步构建", "explanation": "建造者模式适合复杂对象的分步构建。" },
  { "q": "原型模式的核心是？", "options": ["继承", "通过克隆创建对象", "工厂创建", "单例"], "answer": "通过克隆创建对象", "explanation": "原型模式通过克隆原型创建对象。" },
  { "q": "外观模式的作用是？", "options": ["创建对象", "提供简化的接口", "观察变化", "代理访问"], "answer": "提供简化的接口", "explanation": "外观模式提供简化的接口，隐藏复杂性。" },
  { "q": "组合模式用于什么场景？", "options": ["简单对象", "树形结构", "单例对象", "代理对象"], "answer": "树形结构", "explanation": "组合模式用于树形结构，统一处理单个和组合对象。" },
  { "q": "享元模式的目的是？", "options": ["创建对象", "共享对象减少内存", "观察变化", "代理访问"], "answer": "共享对象减少内存", "explanation": "享元模式共享对象，减少内存占用。" },
  { "q": "命令模式的特点是？", "options": ["直接调用", "将请求封装为对象", "观察变化", "代理访问"], "answer": "将请求封装为对象", "explanation": "命令模式将请求封装为对象，支持撤销和重做。" },
  { "q": "状态模式和策略模式的区别是？", "options": ["没有区别", "状态模式状态自动切换，策略模式外部指定", "策略模式自动切换", "状态模式外部指定"], "answer": "状态模式状态自动切换，策略模式外部指定", "explanation": "状态模式状态自动切换，策略模式由外部指定。" },
  { "q": "责任链模式的特点是？", "options": ["单一处理者", "多个处理者依次处理", "并行处理", "随机处理"], "answer": "多个处理者依次处理", "explanation": "责任链模式多个处理者依次处理请求。" },
  { "q": "迭代器模式的作用是？", "options": ["创建对象", "顺序访问集合元素", "观察变化", "代理访问"], "answer": "顺序访问集合元素", "explanation": "迭代器模式提供顺序访问集合元素的方法。" },
  { "q": "中介者模式的作用是？", "options": ["直接通信", "通过中介者协调对象交互", "观察变化", "代理访问"], "answer": "通过中介者协调对象交互", "explanation": "中介者模式通过中介者协调对象交互。" },
  { "q": "备忘录模式用于什么？", "options": ["创建对象", "保存和恢复对象状态", "观察变化", "代理访问"], "answer": "保存和恢复对象状态", "explanation": "备忘录模式保存和恢复对象状态。" },
  { "q": "访问者模式的特点是？", "options": ["修改类", "在不修改类的情况下添加新操作", "观察变化", "代理访问"], "answer": "在不修改类的情况下添加新操作", "explanation": "访问者模式在不修改类的情况下添加新操作。" }
]
